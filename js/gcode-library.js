class GCodeLibrary {
  static parse(gcodeText) {
    const lines = gcodeText.split(/\r?\n/);
    const commands = [];
    
    for (const rawLine of lines) {
      const line = rawLine.trim();
      if (line === '') {
        commands.push({ type: 'empty', raw: rawLine });
        continue;
      }
      
      if (line.startsWith(';')) {
        commands.push({ type: 'comment', raw: rawLine, comment: line.substring(1).trim() });
        continue;
      }
      
      // استخراج الأمر والمعاملات
      const [commandPart, commentPart] = line.split(';');
      const command = this.parseCommand(commandPart.trim());
      
      if (commentPart) {
        command.comment = commentPart.trim();
      }
      
      command.raw = rawLine;
      command.type = 'command';
      commands.push(command);
    }
    
    return commands;
  }

  static parseCommand(commandStr) {
    const parts = commandStr.split(/\s+/);
    const command = {
      code: parts[0].toUpperCase(),
      parameters: {}
    };
    
    for (let i = 1; i < parts.length; i++) {
      const part = parts[i];
      if (part.length < 2) continue;
      
      const axis = part[0].toUpperCase();
      const value = parseFloat(part.substring(1));
      
      if (!isNaN(value)) {
        command.parameters[axis] = value;
      }
    }
    
    return command;
  }

  static stringify(commands) {
    return commands.map(cmd => {
      if (cmd.type === 'empty') return '';
      if (cmd.type === 'comment') return `; ${cmd.comment}`;
      
      let line = cmd.code;
      
      // إضافة المعاملات
      Object.entries(cmd.parameters || {}).forEach(([axis, value]) => {
        line += ` ${axis}${value.toFixed(4)}`;
      });
      
      // إضافة التعليق إذا موجود
      if (cmd.comment) {
        line += ` ; ${cmd.comment}`;
      }
      
      return line;
    }).join('\n');
  }

  static generateHeader(machineType = 'router') {
    const headers = {
      router: [
        '; G-code generated by CNC AI',
        '; Machine: CNC Router',
        'G21 ; Set units to millimeters',
        'G90 ; Absolute positioning',
        'G17 ; XY plane selection',
        'G0 Z5 ; Safe Z height'
      ],
      laser: [
        '; G-code generated by CNC AI',
        '; Machine: Laser Engraver',
        'G21 ; Set units to millimeters',
        'G90 ; Absolute positioning',
        'G0 X0 Y0 ; Start position'
      ],
      threed: [
        '; G-code generated by CNC AI',
        '; Machine: 3D Printer',
        'G21 ; Set units to millimeters',
        'G90 ; Absolute positioning',
        'M82 ; Extruder absolute mode',
        'G28 ; Home all axes'
      ]
    };
    
    return headers[machineType] || headers.router;
  }

  static generateFooter(machineType = 'router') {
    const footers = {
      router: [
        'M5 ; Spindle off',
        'G0 Z10 ; Lift tool',
        'G0 X0 Y0 ; Return to origin',
        'M30 ; Program end'
      ],
      laser: [
        'M5 ; Laser off',
        'G0 X0 Y0 ; Return to origin',
        'M30 ; Program end'
      ],
      threed: [
        'M104 S0 ; Extruder off',
        'M140 S0 ; Bed off',
        'G0 Z50 ; Lift nozzle',
        'M84 ; Disable steppers',
        'M30 ; Program end'
      ]
    };
    
    return footers[machineType] || footers.router;
  }

  static estimateTime(gcodeCommands, feedRate = 1000) {
    let totalDistance = 0;
    let currentX = 0, currentY = 0, currentZ = 0;
    let currentFeedRate = feedRate;
    
    for (const cmd of gcodeCommands) {
      if (cmd.type !== 'command') continue;
      
      if (cmd.parameters.F !== undefined) {
        currentFeedRate = cmd.parameters.F;
      }
      
      if (cmd.code === 'G0' || cmd.code === 'G1') {
        const targetX = cmd.parameters.X !== undefined ? cmd.parameters.X : currentX;
        const targetY = cmd.parameters.Y !== undefined ? cmd.parameters.Y : currentY;
        const targetZ = cmd.parameters.Z !== undefined ? cmd.parameters.Z : currentZ;
        
        const distance = Math.sqrt(
          Math.pow(targetX - currentX, 2) +
          Math.pow(targetY - currentY, 2) +
          Math.pow(targetZ - currentZ, 2)
        );
        
        totalDistance += distance;
        
        currentX = targetX;
        currentY = targetY;
        currentZ = targetZ;
      }
    }
    
    // الوقت بالدقائق
    const timeMinutes = totalDistance / currentFeedRate;
    return {
      distance: totalDistance,
      time: timeMinutes,
      formatted: `${timeMinutes.toFixed(1)} دقيقة`
    };
  }

  static optimizePath(commands, options = {}) {
    const optimized = [...commands];
    
    // إزالة الأوامر الزائدة عن الحاجة
    if (options.removeRedundant) {
      this.removeRedundantMoves(optimized);
    }
    
    // تحسين مسار الحركة
    if (options.optimizeTravel) {
      this.optimizeTravelMoves(optimized);
    }
    
    return optimized;
  }

  static removeRedundantMoves(commands) {
    let lastX, lastY, lastZ, lastFeedRate;
    
    for (let i = commands.length - 1; i >= 0; i--) {
      const cmd = commands[i];
      if (cmd.type !== 'command') continue;
      
      if (cmd.code === 'G0' || cmd.code === 'G1') {
        const currentX = cmd.parameters.X !== undefined ? cmd.parameters.X : lastX;
        const currentY = cmd.parameters.Y !== undefined ? cmd.parameters.Y : lastY;
        const currentZ = cmd.parameters.Z !== undefined ? cmd.parameters.Z : lastZ;
        const currentFeed = cmd.parameters.F !== undefined ? cmd.parameters.F : lastFeedRate;
        
        // إذا كانت الحركة لنفس الموقع، احذفها
        if (currentX === lastX && currentY === lastY && currentZ === lastZ) {
          commands.splice(i, 1);
          continue;
        }
        
        lastX = currentX;
        lastY = currentY;
        lastZ = currentZ;
        lastFeedRate = currentFeed;
      }
    }
  }

  static optimizeTravelMoves(commands) {
    // تنفيذ خوارزميات تحسين المسار
    // يمكن إضافة خوارزميات مثل nearest neighbor
  }
}

window.GCodeLibrary = GCodeLibrary;
